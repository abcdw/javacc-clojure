options {
  LOOKAHEAD = 2;
}

PARSER_BEGIN(ClojureParser)

public class ClojureParser {
    static int forms = 0;
    static int literals = 0;
    static int keywords = 0;
    static int symbols = 0;
    static int lists = 0;
    static int vectors = 0;
    static int maps = 0;
    static int sets = 0;
    static int nestiness = 0;

    public static void main(String[] args) {
        try {
            new ClojureParser(new java.io.InputStreamReader(System.in)).S();
            System.out.println("Syntax is okay");
            System.out.println(
                               "forms: " + forms + "\n" +
                               "keywords: " + keywords + "\n" +
                               "lists: " + lists + "\n" +
                               "vectors: " + vectors + "\n" +
                               "symbols: " + symbols + "\n" +
                               "literals: " + literals + "\n"
                               );
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(ClojureParser)



/* COMMENTS */

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

SKIP:  { " " | "\t" | "\n" | "\r" | ","              }

/* BRACKETS */

TOKEN: {
  // <BRACKET: <LPAR> | <RPAR> | <LSQU> | <RSQU> | <LCUR> | <RCUR> >
  <LPAR: "(">
  | <RPAR: ")">
  | <LSQU: "[">
  | <RSQU: "]">
  | <LCUR: "{">
  | <RCUR: "}">
  }


/* LITERALS */
TOKEN: {
  <NUM: <RATIO> | <INT> | <DOUBLE> >
  | <RATIO: <INT> "/" <INT> >
  | <DOUBLE: (<DIGIT>)+ "." (<DIGIT>)* ("e" (<DIGIT>)+)? >
  | <INT: (<DIGIT>)+ ("r" (<DIGIT>)+)? ("n" | "l" | "L" | "N")?>
  | <NIL: "nil">
  | <STR: "\"" (~["\""] | "\\" "\"")* "\"">
  | <BOOLEAN: "true" | "false">
  | <CHARACTER: "\\" (~[" "]
                     | ("u" <DIGIT><DIGIT><DIGIT><DIGIT>)
                     | ("o" <DIGIT><DIGIT><DIGIT>)
                     | "newline"
                     | "space"
                     | "tab"
                     | "formfeed"
                     | "backspace"
                     | "return") >
  | <KEYWORD: ":" (":")? ((<DIGIT>)* <NS> "/")? (<DIGIT>)* <NAME> >
}

TOKEN: {
  <SYMBOL: <NAME> | <NS> | <NS> "/" <NAME> | <INTEROP> >
  | <INTEROP: (("." | ".-") <NAME> | "." )>
  | <NS: <NAME> ("." <NAME>)*>
  | <NAME: (<LETTER> | <CHAR>) (<DIGIT> | <LETTER> | <CHAR> | "#" )* >
  | <LETTER: ["a"-"z", "A"-"Z"]>
  | <CHAR: ["*", "+", "!", "-", "_", "?", "=", "%", "&", ">", "<"] > // maybe some other chars
  | <DIGIT: ["0"-"9"]>
}

void S(): {} { forms() <EOF> }

void forms(): {} { (form() { ++forms; })* }
void form(): {} {
  literal() { literals++; }
  | symbol()
  | list()
  | vector()
  | set()
  | map()
}

void list(): {} { <LPAR> forms() <RPAR> { ++lists; } }
void vector(): {} { <LSQU> forms() <RSQU> { ++vectors; } }
void set(): {} { "#" <LCUR> forms() <RCUR> { ++sets; } }
void map(): {} { <LCUR> (form() form())* <RCUR> { ++maps; } }

void symbol(): {}
{
  <SYMBOL>
  { ++symbols; }
}

void literal(): {}
{
  <KEYWORD> { ++keywords; } | <CHARACTER> | <NUM> | <NIL> | <STR>
}
